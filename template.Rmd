---
title: "Super Awesome Project Template"
output: word_document
names: "Caleb Bekkum, Luke Spika, Cole Umland, Charlie Wiegel"
date: "2025-04-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Section One
Genius API info 
Client ID: r8BXdSiDmw9qfMoxh2S3f1g4AtvDaPf8XD-TWjkO77sc_hvsglOutM9Pl67I67Tr
Client Secret : pvEdzTUfKqtLbjv0qdxBJrqs5Hj1JQlhf4ICcQPWp3Zfo5j7uO88_34UWDbmT5a38wZP9lrTksDX4r8csgZsVA
Client Access Token: BoaVCPyQtW90wUPpm3lPVgm1b5AJGB0BIBvG1UO9dj473mlajOuyvJ1hrN0Dvw9G
Nickname : Luke5pika

```{r}

# This code chunk is for setting up access and web-scraping song info from the Spotify API

library(httr)
library(jsonlite)
library(rvest)
library(stringr)
library(xml2)

# Genius API Token
genius_token <- "BoaVCPyQtW90wUPpm3lPVgm1b5AJGB0BIBvG1UO9dj473mlajOuyvJ1hrN0Dvw9G" 
# Test song
test_title <- "Blinding Lights"
test_artist <- "The Weeknd"

# Function to search Genius for lyrics of given songs
# inputs: title of song, artist of song, and a given Genius token
# outputs: A url to the Genius page containing the lyrics of the song, as well as the lyrics themselves
search_song <- function(title, artist, token) {
  query <- URLencode(paste(title, artist))
  url <- paste0("https://api.genius.com/search?q=", query)
  res <- GET(url, add_headers(Authorization = paste("Bearer", token)))

  if (status_code(res) == 200) {
    json <- fromJSON(content(res, as = "text"), simplifyVector = FALSE)
    hits <- json$response$hits

    for (hit in hits) {
      result <- hit[["result"]]
      if (!is.null(result)) {
        primary_artist <- result[["primary_artist"]]
        artist_name <- primary_artist[["name"]]

        if (!is.null(artist_name) && grepl(tolower(artist), tolower(artist_name))) {
          return(result[["url"]])
        }
      }
    }
  } else {
    warning("API request failed with status code: ", status_code(res))
  }

  return(NA)
}

#Function to get lyrics
#Inputs: Genius URL
#Outputs: cleaned up lyrics as one line
get_clean_lyrics <- function(url) {
  page <- read_html(url)
  lyrics_nodes <- html_elements(page, '[data-lyrics-container="true"]')

  if (length(lyrics_nodes) == 0) {
    lyrics_nodes <- html_elements(page, 'div.lyrics')  # fallback
  }

  # Collapse all the lyrics text with line breaks between nodes
  lyrics <- lyrics_nodes %>%
    html_text2() %>%  # html_text2() preserves line breaks better
    paste(collapse = "\n")
  
  lyrics <- sub("^.*?\\s[Ll]yrics\\s*", "", lyrics)
  lyrics <- sub(".*â€¦ Read More ", "", lyrics)
  
  # Keep only content after [Intro] or [Verse 1]
  lyrics_after <- sub(".*\\[.*?\\]", "", lyrics, ignore.case = TRUE)

  if (identical(lyrics_after, lyrics)) {
    lines <- strsplit(lyrics, "\n")[[1]]
    lines <- trimws(lines)
    # Look for first line that likely begins real lyrics (e.g., lowercase or punctuation)
    start_idx <- which(grepl("^[a-z]|[[:punct:]]", lines))[1]
    if (!is.na(start_idx)) {
      lyrics_after <- paste(lines[start_idx:length(lines)], collapse = "\n")
    }
  }
  
  # Remove all [Section Headers]
  clean_lyrics <- str_replace_all(lyrics_after, "\\[.*?\\]", "")
  # Trim and fix spacing
  clean_lyrics <- gsub("\\s+", " ", clean_lyrics)
  
  clean_lyrics <- gsub("([a-z])([A-Z])", "\\1 \\2", clean_lyrics)
  clean_lyrics <- gsub("(\\w)\\(", "\\1 (", clean_lyrics)
  clean_lyrics <- gsub("\\)(\\w)", ") \\1", clean_lyrics)
  clean_lyrics <- gsub("([\\)\\?\\!\\.,])(?=\\w)", "\\1 ", clean_lyrics, perl = TRUE)
  clean_lyrics <- gsub('\\"', '', clean_lyrics)
  return(clean_lyrics)
}

```

## Section Two

```{r Luke Spika}
#new project test
```

## Section Three

```{r Cole Umland}
#This table is cleaned up and ready to roll.
library(rvest)
library(dplyr)
library(purrr)
library(stringr)

decade_urls <- c(
  "https://en.wikipedia.org/wiki/List_of_Billboard_Hot_100_number-one_singles_from_1958_to_1969",
  "https://en.wikipedia.org/wiki/List_of_Billboard_Hot_100_number-one_singles_of_the_1970s",
  "https://en.wikipedia.org/wiki/List_of_Billboard_Hot_100_number-one_singles_of_the_1980s",
  "https://en.wikipedia.org/wiki/List_of_Billboard_Hot_100_number-one_singles_of_the_1990s",
  "https://en.wikipedia.org/wiki/List_of_Billboard_Hot_100_number-one_singles_of_the_2000s",
  "https://en.wikipedia.org/wiki/List_of_Billboard_Hot_100_number-one_singles_of_the_2010s",
  "https://en.wikipedia.org/wiki/List_of_Billboard_Hot_100_number-one_singles_of_the_2020s"
)

all_number_ones <- map_df(decade_urls, function(url) {
  page <- read_html(url)

  table <- page %>%
    html_node("table.wikitable") %>%
    html_table(fill = TRUE)

  names(table) <- tolower(names(table))

  if (any(str_detect(names(table), "single|song")) && any(str_detect(names(table), "artist"))) {
    cleaned <- table %>%
      select(contains("single"), contains("artist"), contains("reached")) %>%
      rename_with(~ c("single", "artist", "date")[1:length(.)]) %>%
      # Remove rows with all values that have four characters
      #Clever, ran into the problem where deleting rows with only four characters also deleted songs with years titles (ex: "1999"). Fixed this by changing any to all in the following code line. All rows with years in every column are now deleted
      filter(!apply(., 1, function(row) all(nchar(as.character(row)) == 4)))
    return(cleaned)
  } else {
    return(NULL)
  }
})

```

## Section Four 

```{r, eval=FALSE}

library(tidyverse)

# --- 3. Batch Processing with Progress Saving ---
process_batch <- function(data, start_row, end_row, token, output_file) {
  results <- list()

  for (i in start_row:end_row) {
    song <- data[i, ]
    cat("Processing [", i, "]:", song$single, "by", song$artist, "\n")

    url <- tryCatch(search_song(song$single, song$artist, token), error = function(e) NA)
    Sys.sleep(0.5)  # Respect API limits

    lyrics <- if (!is.na(url)) tryCatch(get_clean_lyrics(url), error = function(e) NA) else NA
    Sys.sleep(0.5)

    results[[i - start_row + 1]] <- song %>%
      mutate(genius_url = url, lyrics = lyrics)

    # Save after each row (or do batch-save every 10 rows if preferred)
    write_csv(bind_rows(results), output_file, append = file.exists(output_file))
  }

  return(bind_rows(results))
}

# Example usage
# To process the first 50 rows and save results to 'lyrics_output.csv'
output_file <- "lyrics_output.csv"
start_index <- 1
end_index <- 1185  # Change this to batch size you want

# Optional: Skip already processed rows
if (file.exists(output_file)) {
  processed <- read_csv(output_file, show_col_types = FALSE)
  start_index <- nrow(processed) + 1
}

if (start_index <= nrow(all_number_ones)) {
  process_batch(all_number_ones, start_index, min(end_index, nrow(all_number_ones)), genius_token, output_file)
} else {
  cat("All songs already processed.\n")
}

processed <- "lyrics_output.csv"
```
##Section 5 Cole Umland
```{r, echo=FALSE}
# Count how many times the title appears in the lyrics (case-insensitive)
count_title_repeats <- function(title, lyrics) {
  if (is.na(lyrics) || lyrics == "") {
    return(NA)
  }
  
  # Normalize title and lyrics: lowercase, remove punctuation
  clean_title <- tolower(gsub("[[:punct:]]", "", title))
  clean_lyrics <- tolower(gsub("[[:punct:]]", "", lyrics))
  
  # Split lyrics into words and match title
  title_words <- strsplit(clean_title, "\\s+")[[1]]
  pattern <- paste0("\\b", paste(title_words, collapse = "\\s+"), "\\b")
  
  # Count matches
  match_count <- str_count(clean_lyrics, regex(pattern, ignore_case = TRUE))
  return(match_count)
}

cat("Title repets in Blinding Lights:\n")
title <- "Blinding Lights"
lyrics <- get_clean_lyrics(search_song(title, "The Weeknd", genius_token))
count_title_repeats(title, lyrics)

cat("Title repeats in Shake Tt Off:\n")
title <- "Shake It Off"
artist <- "Taylor Swift"
url <- search_song(title, artist, genius_token)
lyrics <- get_clean_lyrics(url)
count_title_repeats(title, lyrics)
```
  Initially, in our test for title repetitiveness we noticed the drastic disparities between title examples. Some songs, such as "Blinding Lights" by The Weekend seem to have no title repetitions in the lyrics. This although isn't the necessarily the case as the words "blinded," and "lights" are in the song, just not exactly as in the title. In contrast, songs like "Shake It Off," by Taylor Swift explicitly state the title in their lyrics. Realizing this, we were led to try more sophisticated repetitive tests to see when titles were included in song lyrics. The two methods we used to test for title repetitiveness in the song lyrics were the fuzzy method and the Stem method.

The Fuzzy Method

Knowing that some songs had soft title repetitions and some songs had explicit repetitions, we wanted to create a test that counted explicit repetitions with some leeway. This way, songs that had their title in their lyrics, but in just a little different of a format, would be counted as a repetition. 

To determine how close the title had to be in the lyrics to count as a repetition, we created an arbitrary distance called "max_distance." Anything in the lyrics that was close enough to the title, was then counted as a repetition. How we determined this distance was through trail and error. The small the max distance value (e.g. 0), the more exact the lyrics had to be to the title to be counted as a repetition. In the case of a max distance of zero, only exact repetitions were allowed to count as repeats. The larger the max distance (e.g. 10), the more typos and differences were allowed to be counted as a title repetition. We tested higher and lower max distance values. In this process, we discovered that songs with short titles were picking up more title repeats coupled with larger max distances. This is because the shorter the title, the easier it would be for any word with a certain amount of typos to match with it. We settled on a max distance of five by testing certain examples of both high and low repetitiveness directly with their lyrics from Genius to see how accurate the test was. 

## Section 5 Cole Umland
```{r, message=FALSE}
#Fuzzy matching idea
library(dplyr)
library(purrr)
library(stringdist)

#The smaller the max distance, the closer the matches need to be to count. A max_distance of 5 would allow for some typos but wouldn't be too fuzzy to count too much
count_fuzzy_title_repeats <- function(title, lyrics_text, max_distance = 5, ngram_window = 5) {
  if (is.na(lyrics_text) || is.null(lyrics_text)) return(NA)
  
  # Preprocess: lowercase, remove extra white space
  lyrics_text <- tolower(lyrics_text)
  title <- tolower(title)
  
  # Split into words
  words <- unlist(strsplit(lyrics_text, "\\s+"))
  title_len <- length(strsplit(title, "\\s+")[[1]])

  # Create n-grams (sliding windows of length matching title or a bit more)
  ngram_size <- max(title_len, 1)
  ngrams <- sapply(1:(length(words) - ngram_size + 1), function(i) {
    paste(words[i:(i + ngram_size - 1)], collapse = " ")
  })

  # Compute string distances
  distances <- stringdist::stringdist(ngrams, title, method = "lv")

  # Count how many are within the allowed distance
  sum(distances <= max_distance, na.rm = TRUE)
}

##########
# Apply fuzzy matching directly using mutate + map2
#Eventually, we need to apply this to our prefect table and not processed
fuzzy_results <- processed %>%
  mutate(
    fuzzy_repeats = map2_int(single, lyrics, ~ tryCatch(
      count_fuzzy_title_repeats(.x, .y, max_distance = 5),
      error = function(e) NA
    ))
  )
# View songs with high repetition
#This reads the top songs with higher repetition first, and the rest in descending order. May not be needed in the future
fuzzy_results %>% arrange(desc(fuzzy_repeats)) %>% head(10)

# Simplified function using existing lyrics
process_song_fuzzy <- function(single, lyrics, max_distance = 5) {
  cat("Processing:", single, "\n")
  
  fuzzy_count <- tryCatch(
    count_fuzzy_title_repeats(single, lyrics, max_distance),
    error = function(e) {
      cat("Error:", e$message, "\n")
      return(NA)
    }
  )
  
  return(tibble(
    single = single,
    fuzzy_repeats = fuzzy_count
  ))
}

# Apply to first 20 rows of processed data frame
fuzzy_results <- processed %>%
  slice(1:20) %>%
  mutate(
    fuzzy_repeats = map2_int(single, lyrics, ~ process_song_fuzzy(.x, .y)$fuzzy_repeats)
  )

# View results
print(fuzzy_results %>% select(single, artist, fuzzy_repeats))

#Mutating the table to add a new column with all the fuzzy results in it
processed <- processed %>%
  mutate(
    fuzzy_repeats = map2_int(single, lyrics, ~ {
      lyrics_text <- if (length(.y) > 1) paste(.y, collapse = " ") else .y
      count_fuzzy_title_repeats(.x, lyrics_text, max_distance = 5)
    })
  )
```

